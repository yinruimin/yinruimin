<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android Support Annotations]]></title>
      <url>%2F2017%2F01%2F22%2FAndroidSupportAnnotations%2F</url>
      <content type="text"><![CDATA[在Android Support Library19.1版本中，Android工具小组引入了几个很酷的注解类型，供开发者在工程中使用。Support Library自身也使用这些注解，这是一个好兆头。就让我们好好研究下。 通过gradle可以很容易的把这些注解添加到我们的工程中： compile &apos;com.android.support:support-annotations:20.0.0&apos; 有三种类型的注解可供我们使用： Nullness注解； 资源类型注解； IntDef和StringDef注解； 我们将通过代码例子来讲解每一种类型的作用以及在工程中如何使用它们。 Nullness注解使用@NonNull注解修饰的参数不能为null。在下面的代码例子中，我们有一个取值为null的name变量，它被作为参数传递给sayHello函数，而该函数要求这个参数是非null的String类型： public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String name = null; sayHello(name); } void sayHello(@NonNull String s) { Toast.makeText(this, &quot;Hello &quot; + s, Toast.LENGTH_LONG).show(); } } 由于代码中参数String s使用@NonNull注解修饰，因此IDE将会以警告的形式提醒我们这个地方有问题：如果我们给name赋值，例如String name = “Our Lord Duarte”，那么警告将消失。使用@Nullable注解修饰的函数参数或者返回值可以为null。假设User类有一个名为name的变量，使用User.getName()访问，那么我们可以编写如下代码： public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); User user = new User(&quot;Our Lord Duarte&quot;); Toast.makeText(this, &quot;Hello &quot; + getName(user), Toast.LENGTH_LONG).show(); } @Nullable String getName(@NonNull User user) { return user.getName(); } } 因为getName函数的返回值使用@Nullable修饰，所以调用： Toast.makeText(this, &quot;Hello &quot; + getName(user), Toast.LENGTH_LONG).show(); 没有检查getName的返回值是否为空，将可能导致crash。 资源类型注解是否曾经传递了错误的资源整型值给函数，还能够愉快的得到本来想要的整型值吗？资源类型注解可以帮助我们准确实现这一点。在下面的代码中，我们的sayHello函数预期接受一个字符串类型的id，并使用@StringRes注解修饰： public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sayHello(R.style.AppTheme); } void sayHello(@StringRes int id) { Toast.makeText(this, &quot;Hello &quot; + getString(id), Toast.LENGTH_LONG).show(); } } 而我们传递了一个样式资源id给它，这时IDE将提示警告如下：类似的，我们把警告的地方使用一个字符串资源id代替警告就消失了： sayHello(R.string.name); IntDef和StringDef注解我们要介绍的最后一种类型的注解是基于Intellij的“魔术常量”检查机制（http://blog.jetbrains.com/idea/2012/02/new-magic-constant-inspection/） （我们不需要详细了解这个机制具体是如何实现的，想了解的话可以点击链接）。 很多时候，我们使用整型常量代替枚举类型（性能考虑），例如我们有一个IceCreamFlavourManager类，它具有三种模式的操作：VANILLA，CHOCOLATE和STRAWBERRY。我们可以定义一个名为@Flavour的新注解，并使用@IntDef指定它可以接受的值类型。 public class IceCreamFlavourManager { private int flavour; public static final int VANILLA = 0; public static final int CHOCOLATE = 1; public static final int STRAWBERRY = 2; @IntDef({VANILLA, CHOCOLATE, STRAWBERRY}) public @interface Flavour { } @Flavour public int getFlavour() { return flavour; } public void setFlavour(@Flavour int flavour) { this.flavour = flavour; } } 这时如果我们使用错误的整型值调用IceCreamFlavourManager.setFlavour时，IDE将报错如下： IDE甚至会提示我们可以使用的有效的取值：我们也可以指定整型值作为标志位，也就是说这些整型值可以使用’｜’或者’&amp;’进行与或等操作。如果我们把@Flavour定义为如下标志位： @IntDef(flag = true, value = {VANILLA, CHOCOLATE, STRAWBERRY}) public @interface Flavour { } 那么可以如下调用： iceCreamFlavourManager.setFlavour(IceCreamFlavourManager.VANILLA &amp; IceCreamFlavourManager .CHOCOLATE); StringDef用法和@IntDef基本差不多，只不过是针对String类型而已。关于将来计划增加哪些新的注解类型或者这些注解的依赖以及和Intellij自身的注解如何交互等等问题，可以查看网址：http://tools.android.com/tech-docs/support-annotations。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Fiddler抓取Android客户端HTTPS链接]]></title>
      <url>%2F2017%2F01%2F21%2FCaptureTraffic%2F</url>
      <content type="text"><![CDATA[下载Fiddler客户端 配置Fiddler Options 将手机与电脑置于同一网络，配置手机端证书 Fiddler客户端开始Capture Traffic 下载Fiddler Free Download 配置Fiddler Options 配置手机端证书查看PC的IP地址，端口Fiddler默认为8888，在手机浏览器输入ip和端口，下载证书 Capture Traffic TIPS: 只能抓常规APP的https包，某些金融类APP对https证书进行了校验，还需要将Fiddler代理服务器的证书导到Android设备上才能抓这些APP的包 HTTPS知识拓展]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对微信小程序的一些观察和思考]]></title>
      <url>%2F2017%2F01%2F09%2FWeChatSmallProgramAnalysis%2F</url>
      <content type="text"><![CDATA[入口2017年1月9日，微信小程序开放体验。小程序的入口目前依赖 全名搜索 扫描二维码 点击链接 三种方式开启，一般用户看不到小程序入口，只有触发了上述三种方式中的一种，才会在发现页面产生小程序的入口 点开之后是这样的 小程序支持分享链接，置顶在聊天界面但是，置顶之后没有取消置顶的操作，会在一定时间内自动消失置顶 添加到桌面和原生App无异 体验小程序依托于微信，所以在微信后台进程开启的情况下，和原生App相比，加载速度略胜一筹。 但是，将微信进程杀掉，去点桌面小程序，出现两个非常不好的体验，一个是桌面显示加载中的菊花转了4秒，另一个是出现了两次小程序未发布的八阿哥，退出后重新进入正常。 部分需要登录的小程序，在开启之后，直接触发微信登录，简化成Button的不断点击，这需要之前的账号是通过微信第三方授权登录的，不然还得走一遍注册流程 微信的野心脑海浮现两个情景： 2015年App开发圈对于原生App和Web App谁死谁活的讨论 2016年Google Instant Apps API的发布 或许是因为在中国这个自成一体的互联网环境中，微信才有机会这么一呼百应，可是小程序这个东西个人觉得有种Google给别人做了嫁衣的感觉。 2014年11月，马化腾在世界互联网大会上提出腾讯要链接一切，要成为互联网连接器。 连接人与人 连接人与服务 连接人与商业 连接人与物品 人与人的连接，微信已经实现，目前微信的DAU达到8亿，每个中国人必备的应用就是微信。 人与服务的连接，通过服务号内置服务连接起来，通过微信订阅，阅读，娱乐等完成服务的转化。 人与商业的连接，微信的支付环节打通了整个商业链条。 人与物品的连接，理想的状态是钢铁侠那般混合现实但是目前的技术环境成本实在是太高，或许有一种折中的办法 小程序的存在价值在微信公开课上，张小龙举了两个小程序的例子： 在公交车上，你扫一下公交站牌的二维码就可以了解下一辆公交车到站的时间 在汽车站，扫一下汽车站的二维码就可以购买车票，而不需要排长队 在当前的技术条件下，二维码成了最可能实现人和物品连接的手段，二维码的背后，可以是信息，可以是服务，微信想让小程序做连接线上和线下的载体，让二维码做现实世界和数字世界的超链接，连接更多线下场景。 背后的产品理念 以用户为中心，其他一切水到渠成 大胆假设，小心求证 App的世界已经趋于饱和，马太效应越来越明显，所有的App都想尽一切办法，在用户所能看到的地方做营销，就像是在做垂死的挣扎，严重损害用户得了利益。 小程序或许可以让这一切尘归尘，土归土，回归到原点，重新出发，重塑规则。 一直以来，想做移动端统一入口的产品数不胜数，但是真正能操刀起山的也只有微信这样的产品王。 开屏广告5秒钟 加载界面2秒钟 寻找服务2秒钟 营销广告1秒钟 使用一项服务时间被App强制分割，真正对用户产生价值也就几秒钟，用户的时间很宝贵，要让用户第一次使用产品就喜欢上，就要懂得放手，在最短的时间内感受产品的核心，而不是： 应用商店下载App 打开App，看5秒广告 第一次花30秒注册 功能层层包裹，花30秒寻找 关注点应该放在”即用”，而不是”即走”上，也是一个积极和消极的对比，所以从用户的角度考虑产品的话，就是优化流程，建立最短路径。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Keep产品发展概述]]></title>
      <url>%2F2017%2F01%2F04%2FKeepProductGrowing%2F</url>
      <content type="text"><![CDATA[产品概要 产品名称：Keep移动健身教练入选理由： Keep是目前最火爆的线上健身服务平台。2015年上线，2016年5月获3200万美元C轮融资。以健身视频教学切入，为白领尤其是健身小白用户，提供线上健身健身训练服务，满足用户碎片化，随时随地的健身需求，快速积累用户流量。 2014年46号文件发布，全名健身上升为国家战略后，民众对运动健身的关注度也迅速上升 2015年，体育分口大热，资本一拥而入，2015年体育类投资项目151笔，是2014年同类投资必输的3倍，是以往所有同类投资笔数的2倍多，但一般是追风口的种子/天使轮投资。 2016年，多个运动健身类长夜项目遭遇自精炼断裂，商业模式膜清洗，没有触达用户痛点无法激活用户使用和付费意愿，创业团队，资本寒冬难以融资等问题，发展难以为继，选择关闭或者转型。 产品截图 产品定位，用户场景产品定位：移动健身服务平台用户定位：还没有形成持久健身习惯的健身小白用户需求： 基本型需求：用户希望在Keep能够随时找到专业的健身教程视频，最好是真人同步训练视频；同时可以根据自身不同的身体素质，科学的推荐或安排相应的健身训练方案，并且能够提醒用户按时完成训练；对训练内容以及相应的数据要实时更新并且详细记录，以便于用户检查自己的训练情况，以及向其他人炫耀训练成果。 期望性需求：用户可以在Keep上发现一个和自己同样的人组成的社区，可以分享炫耀自己，也可以浏览别人的分享内容，最好是可以看到很多身材好型男美女分享的图片，可以饱眼福治花痴，还可以激励自己坚持健身；用户还可以在Keep社区中找到各种专业的健身知识；用户在Keep上下载训练视频，可以“秒下载”而且耗费流量极少；用户可以在Keep组建或加入不同的兴趣小组，相互监督相互学习。 兴奋型需求：用户在Keep这个健身社区中找到归属感，和其他用户产生情感；用户在Keep社区交流中发现合适心仪的训练装备，可直接在Keep内部完成购买，并且品质有保障。 用户痛点： 痛点一：去健身房没有充裕的时间（时间碎片化），而且价格都偏贵（健身预算少） 痛点二：想自己锻炼，却不知道如何训练才更科学，对身体更好，而网上训练课程又良莠不齐 痛点三：健身训练很枯燥，很容易坚持不下来，身边又没有合适的人进行监督和提醒 解决方案： 方案一：使用的及时性和满足对碎片化时间利用：能够解决即时的问题，使用户能够利用碎片化的时间，不拘泥于场景的限制，随时随地完成运动的需求。 方案二：傻瓜式的标准化课程满足不同基础人群的使用：针对“小白”人群，根据用户健身需求定制个性化训练计划，跟着视频课程训练就可以达成目标。面对高级进阶人群，可以DIY定制 核心业务逻辑 产品信息架构 大事件2016 年 10 月：Keep 用户量突破 60,000,0002016 年 8 月：完成腾讯 C＋轮战略投资2016 年 3 月：完成 Morningside（晨兴资本）、GGV（纪源资本）领投的 3200 万美金 C 轮融资，BAI（贝塔斯曼亚洲投资基金）跟投2016 年 3 月：Keep 被预装到大中华区苹果零售店2016 年 1 月：被 App Store 评选为 2015 年度精选应用2015 年 11 月：Keep 用户量突破 10,000,0002015 年 7 月：获得 GGV（纪源资本）领投的 1000 万美金 B 轮融资，BAI（贝塔斯曼亚洲投资基金）和 Ventech（银泰资本）跟投2015 年 4 月：Keep 安卓版上线2015 年 3 月：获得 Ventech（银泰资本）和 BAI（贝塔斯曼）500 万美金 A 轮融资2015 年 2 月：Keep 登陆 App Store，蝉联 App Store 健康健美榜榜首数日2014 年 11 月：完成 300 万人民币天使融资2014 年 10 月：Keep 团队成立 功能迭代和运营节奏 第一阶段：2014年2月到2015年7月，Keep社区冷启动时期，主要针对产品逻辑的打磨。产品：打磨核心功能”训练课程”，引导用户只有训练完成之后才能发表动态，总体来说还是一款弱社区强工具的产品。运营：以拉新，精选用户动态为主。 第二阶段：2015年7月~2016年5月，Keep精心打磨产品，多次引入资本，开启迅速增长之路。产品：推出训练计划，和小组功能。在第一阶段沉淀的用户数据，开始建立用户等级，逐渐的有了社区的雏形，同时适配了iOS平台很多特有功能运营：以UGC为主，创建话题，引导用户发表动态，精选动态展示。 第三阶段：2016年5月至今，丰富并完善Keep用户量进一步增长。产品：用户量突破数百万，开始尝试电商变现，走B2C的线路，同时切入跑步用户群。运营：产品成型后，开始运营发力 内容：之前是UGC精选动态变更为UGC+PGC+精选 用户：结合内容、商业运营，进行线上、线下活动运营；结合功能运营，重点对跑步用户群进行拉新 品牌：品牌广告，明星代言 商业：toC电商，toB广告 数据来源：艾瑞咨询，百度指数，AppAnnie]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网易严选：实用消费主义的探路者]]></title>
      <url>%2F2016%2F12%2F18%2FNetEaseYanXuan%2F</url>
      <content type="text"><![CDATA[网易严选，不单单是精心打磨的互联网产品，更是对制造产业链的输血改造，供应侧改革的成功案例 背景一:去日本买只马桶盖今年蓝狮子的高管年会飞去日本冲绳岛开，我因为参加京东年会晚飞了一天，飞机刚落在那霸机场，看微信群里已经是一派火爆的购物气象：小伙伴们在免税商场玩疯了，有人一口气买了六只电饭煲！到日本旅游，顺手抱一只电饭煲回来，已是流行了一阵子的“时尚”了，前些年在东京的秋叶原，满大街都是拎着电饭煲的中国游客。我一度对此颇为不解，“日本的电饭煲真的有那么神奇吗？”就在一个多月前，我去广东美的讲课，顺便参观了美的产品馆，它是全国最大的电饭煲制造商，我向陪同的张工程师请教了这个疑问。 工程师迟疑了三秒钟，然后实诚地告诉我，日本电饭煲的内胆在材料上有很大的创新，煮出来的米饭粒粒晶莹，不会黏糊，真的不错，“有时候我们去日本，领导也会悄悄地让我们拎一两只回来。” “我们在材质上解决不了这个问题？” “现在还没有找到办法。” 美的创办于1981年，从1993年开始生产电饭煲，它与日本三洋合作，引进模糊逻辑电脑电饭煲项目，逐渐成为国内市场的领先者。近些年来，随着市场占比的反转，竞合关系发生微妙改变，日本公司对中国企业的技术输出变得越来越谨慎，“很多拥有新技术的家电产品，不但技术对中国企业封锁，甚至连产品也不外销，比如电饭煲就是这样。” 也就是说，很多年来，“中国制造”所推行的、用“市场换技术”的后发战略已经失效了。这样的景象并不仅仅发生在电饭煲上，从这些天蓝狮子高管们的购物清单上就可以看出冰山下的事实—— 很多人买了吹风机，据说采用了纳米水离子技术，有女生当场做吹头发试验，“吹过的半边头发果然蓬松顺滑，与往常不一样”；很多人买了陶瓷菜刀，据说耐磨是普通钢的60倍，“切肉切菜那叫一个爽，用不到以前一半的力气，轻松就可以把东西切得整整齐齐了”；很多人买了保温杯，不锈钢真空双层保温，杯胆超镜面电解加工，不容易附着污垢，杯盖有LOCK安全锁扣，使密封效果更佳，这家企业做保温杯快有一百年的历史了；很多人买了电动牙刷，最新的一款采用了LED超声波技术，重量比德国的布朗轻一半，刷毛更柔顺，适合亚洲人口腔使用…… 最让我吃惊的是，居然还有三个人买回了五只马桶盖。 —-摘自吴晓波《中国中产为何蜂拥去日本买马桶盖》 背景二：无印良品发展史“无印良品(MUJI)”创始于日本，其本意是“没有商标与优质”。虽然极力淡化品牌意识，但它遵循统一设计理念所生产出来的产品无不诠释着“无印良品”的品牌形象，它所倡导的自然、简约、质朴的生活方式也大受品位人士推崇。 1980年，世界经济增长陷入低迷，日本也经历了严重的能源危机。当时的消费者不仅要求商品有好的品质，也希望价格从优。在这种情况下，“无品牌”概念在日本诞生了。当年，木内正夫创办了“无印良品”公司，向市场推出了第一批无品牌产品。这些产品包装简洁，降低了成本，所使用的口号是“物有所值”。 1983年，无印良品在东京青山开设了第一家旗舰店。由于大受消费者的肯定，几年内在日本就有了上百家专卖店。 1991年，无印良品在伦敦开设了它的第一家海外专卖店，此后陆续进入法国、瑞典、意大利、挪威、爱尔兰等国家。 1995年无印良品进入家电市场，推出了冰箱、洗衣机、电话、电锅、微波炉等电气商品。同年8月，无印良品的股票在JASDAQ店头市场公开。 1996年3月，开始经营了花卉贩售商店“花良”。 1998年12月，无印良品于东京证券交易所二部（中小板）上市。 1999年，无印良品跨足服饰业、开始销售孕妇装与童装。 2001年，与日产汽车公司合作，推出了无印良品汽车，称为“MUJI Car 1000”。 2000年8月，无印良品在东京证券交易所一部（主板）上市。 2005年7月，其上海专卖店正式开业。 2015年7月24日，日本“无印良品”的母公司良品计划决定在2015年8月以后，将在中国销售的衣物等约260个品类的商品价格平均下调20%。虽然近期中国股市震荡，经济减速也令人担忧，但良品计划在华业绩依然良好，2015年3-5月的营业收入同比大涨90%。 2016年，中国大陆第200家店开业。 背景三：供给侧改革从经济学的角度来说，在社会资源比较充沛的时候，关注资源分配的公平和效率，让需求者得到满足；当经济下滑、资源不充沛的时候，应将更多精力放在如何创造更多资源，然后再谈分配问题。 供给侧改革就是通过创新供给来反向影响需求的问题。市场交易人之间很大的障碍和成本来自信任关系的建立，但通过互联网和大数据却可以大大降低供求双方建立信任的成本，也提供了更大收益的可能性。比如之前就算私家车闲置，也不会有人将其通过交易来变现，因为这样做成本太高，风险太大。但随着滴滴出行等平台的出现，碎片化的闲置资源可以实现共享。 背景四：中国制造新常态据德国《商报》7月28日报道，中国企业已经发生了重大变化，这体现在电信巨头华为公司身上。华为被视为世界第二大经济体最全球化的企业。该公司直到2011年还作为初级设备制造商为客户贴牌生产智能手机，也就是说不是生产华为自主品牌的手机。 华为因此扮演了当时中国企业典型的角色。作为世界工作台，中国的生产商都躲在全球品牌后面。智能手机、电视机和空调虽然在中国制造，但却贴上欧美品牌的标签进行销售。没有品牌，价格便宜，这曾经是中国商品的标准特点。 报道称，但这已经成为历史。如今，设计和打造品牌成为很多中国企业的首要目标。其中打前阵的是电子产品和电子商务企业。电视机生产商海信集团今年夏天成为欧洲杯56年历史上首个中国顶级赞助商。海尔和美的等家电制造商也致力于成为国际品牌。 中国的互联网企业在国际上也变得更加出名。阿里巴巴把它的支付服务系统支付宝带到了德国商店的付款台。该集团首先瞄准的是在旅途中想通过智能手机随心购物的中国游客。从长远来看，这家电子商务企业也将给欧洲人提供服务。互联网企业腾讯公司试图通过聊天软件微信提高自己的全球威望。搜索服务商百度公司也通过广告攻势推进自己的全球扩张。 报道称，华为是个榜样：在推出自主品牌的智能手机5年后，这家位于中国深圳市的企业已经成长为仅次于三星和苹果的世界第三大手机制造商。在全球智能手机市场销售业绩走弱的背景下，华为的销售额仍在今年第一季度实现了猛增。 报道分析，中国企业的崛起有三个原因： 第一，质量好。中国生产商如今有能力制造出高质量的产品，而国际品牌的优势在缩小。在提供相同品质的产品方面，中国生产商做得越来越好，这是打动顾客的基本前提。最好的例子是深圳的大疆公司。借助良好的技术，这家中国企业崛起为民用无人机市场的领头羊。今天，全球售出的无人机有3/4是由中国人制造的。 第二，资金充足。在过去几年中，这些公司在中国国内赚足了钱，能够负担得起耗资巨大的广告攻势。智能手机生产商小米公司也支出大量资金用于宣传，以便为自己的产品在亚洲、美国和欧洲打广告。 第三，国内市场疲软。自从中国告别涡轮式增长以来，企业开始扭转方向。这个拥有14亿人口的大国仍是一个重要的销售市场，但企业越来越意识到，必须更多地着眼于全球市场才能保证长期增长。很多企业都是以新兴工业国家为起点，但华为表明，中国企业也可以在欧洲这样的成熟市场上立足。 中国制造逐渐从廉价商标变为优质品牌。电子产品和电子商务公司的成功只是一个开始，消费品生产商可能紧随其后。 从2015年开始，”日本工匠精神”这个词就在我这个刚进入社会不久的市井小民耳边环绕，工匠精神最原始的释义从手工业也延伸到了制造业和互联网行业，成为了一种专注于打磨精品的敬业精神。 国内中产阶级群体的成长，对于生活品质的提高产生了巨大的需求。整个亚洲地区，和中国国情，文化背景最相似的发达国家日本就成了焦点。 上世纪八十年代，世界经济低迷，日本陷于能源危机。当时的消费者不仅要求商品有好的品质，也希望价格从优，以简约、朴素为特征，极简主义风格的无印良品应运而生。 2015年初，中国与全球制造业疲软，为优化产业结构，提高资源利用率，国家提出供应侧改革试验。中国企业发生了重大变化，中国制造逐渐从全球品牌后面走到大众面前，电子产品和电子商务公司的成功只是一个开始，消费品生产商可能会紧随其后。 11月10日，网易（NASDAQ：NTES）发布2016年第三季度财报，得益于游戏和电商业务的强力增长，网易净收入和净利润连续创历史新高。其中，网易严选等电商业务净收入为20.8亿元（3.12亿美元），同比增幅达到107.2%，成为网易继游戏之后的第二大营收主力。 网易严选采用超低SKU，帮助客户挑选商品，甚至主动去除了所有品牌的溢价。所有商品直接委托工厂生产，一律以网易严选自有品牌出售。不自建物流，统一使用中心仓库再委托顺丰发货，在保证较快物流速度的用户体验下尽可能降低成本。 网易严选符合了现在国内中产阶级更加务实，更加注重产品本身品质而不愿意支付过多的品牌溢价的实用主义消费观念。但网易严选的价格并没有特别的吸引力。所以网易严选具有一定的中介性质，只是它的利润仍然是来自于商品差价，还是超市模式。 或许，网易严选在未来会有一些针对中产阶级的零售新玩法，拭目以待。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：Fragment生命周期概述]]></title>
      <url>%2F2016%2F12%2F14%2FFragmentLifecycle%2F</url>
      <content type="text"><![CDATA[简介 使用说明 生命周期 简介Fragment就是小型的Activity，它是在Android3.0时出现的。Fragment是表现Activity中UI的一个行为或者一部分。可以把fragment想象成activity的一个模块化区域，有它自己的生命周期，接收属于它自己的输入事件，并且可以在activity运行期间添加和删除（有点像一个可以在不同的activity中重用的子Activity）。 Fragment必须被嵌入到一个activity中。它们的生命周期直接受其宿主activity的生命周期影响。当一个activity正在运行时，就可以独立地操作每一个Fragment，比如添加或删除它们。 Fragment可以定义自己的布局、生命周期回调方法，因此可以将fragment重用到多个activity中，因此可以根据不同的屏幕尺寸或者使用场合改变fragment组合。 使用说明如何创建Fragment 为Fragment定义一个布局 定义类继承Fragment 重写类中的onCreateView方法，返回一个View对象作为当前Fragment的布局。 fragment第一次绘制它的用户界面的时候，系统会调用onCreateView()方法。为了绘制fragment的UI，此方法必须返回一个作为fragment布局的根的view。如果fragment不提供UI，可以返回null。 public class ExampleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_example, null); return view; } } 如何将Fragment添加到ActivityActivity必须在清单文件中进行声明，但是Fragment不需要，Fragment只需要在Activity的布局文件中声明就可以了。 &lt;fragment android:id=&quot;@+id/fmt_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:name=&quot;com.gunther.fragment.exampleFragment&quot; /&gt; 当系统创建这个activity layout时，它实例化每一个在layout中指定的Fragment，并调用它们的onCreateView()方法，来获取每一个Fragment的layout，系统将从Fragment返回的View 直接插入到元素所在的地方。 每一个fragment都需要一个唯一的标识，如果activity重启，系统可以用来恢复Fragment，并且可以用id来捕获Fragment来处理事务，例如移除它。有3种方法来为一个fragment提供一个ID，具体如下所示： 为android:id属性提供一个唯一ID; 为android:tag属性提供一个唯一字符串; 如果以上2个你都没有提供，系统将使用容器view的ID; 如何切换Fragment要在activity中管理Fragment，需要使用FragmentManager可以通过调用activity的getFragmentManager()取得它的实例。案例：点击不同的按钮切换到不同的Fragment进行显示。具体实现步骤： 设置布局文件：添加三个按钮用于切换Fragment，并在按钮下方添加一个FrameLayout用来替换成响应的Fragment。 创建三个Fragment，SportsFragment、NewsFragment、GameFragment。 public class SportsFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_sports, null); return view; } } 其余两个Fragment跟SportsFragment代码一致，只是布局文件不同。 添加切换Fragment的逻辑，这个是新闻频道按钮的点击事件 public void news(View view){ //获取Fragment管理器对象 FragmentManager manager = getFragmentManager(); //开启事务 FragmentTransaction transaction = manager.beginTransaction(); //将FrameLayout控件替换成Fragment对象 transaction.replace(R.id.frame, new NewsFragment()); //提交事务 transaction.commit(); } sports()法，games()法同上 Fragment的生命周期Fragment的生命周期和activity生命周期很像，其生命周期方法如下所示。 onAttach：绑定到activity onCreate：创建fragment onCreateView： 创建fragment的布局 onActivityCreated： activity创建完成后 onStart： 可见, 不可交互 onResume： 可见, 可交互 onPause： 部分可见, 不可交互 onStop：不可见 onDestroyView： 销毁fragment的view对象 onDestroy： fragment销毁了 onDetach： 从activity解绑了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：ContentProvider使用说明]]></title>
      <url>%2F2016%2F12%2F13%2FContentProviderDemoLearning%2F</url>
      <content type="text"><![CDATA[简介 使用说明 ContentObserver 简介ContentProvider即内容提供者，是Android的四大组件之一。内容提供者是应用程序之间共享数据的接口，Android系统将这种机制应用到方方面面。比如：联系人Provider专为不同应用程序提供联系人数据；设置Provider专为不同应用程序提供系统配置信息，包括内置的设置应用程序等。当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。 虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用SharedPreferences共享数据，需要使用SharedPreferences API读写数据。 而使用ContentProvider共享数据的好处是统一了数据访问方式。内容提供者将数据封装，只暴露出我们希望提供给其他程序的数据。内容提供者中数据更改可被监听。 使用说明 定义类继承ContentProvider，根据需要重写内部方法(增删改查) 在清单文件的节点下进行配置，标签中需要指定name和authorities属性name：类名，包名从程序Package开始，以“.”开始authorities：是访问Provider时的路径，要唯一 URI代表要操作的数据，由scheme、authorites、path三部分组成content：//cn.gunther.sqlite.provider/personscheme：固定为content，代表访问内容提供者authorites：节点中的authorites属性path：程序定义的路径，可根据业务逻辑定义 示例代码： 新创建一个Android工程，工程名《MyContentProvider》，包名：com.gunther.provider。 在com.gunther.provider.dao包下新建一个PersonOpenHelper类继承SQLiteOpenHelper类，该类用于创建数据库。 public class PersonOpenHelper extends SQLiteOpenHelper { public PersonOpenHelper(Context context, String name, CursorFactory factory, int version) { super(context, name, factory, version); } public PersonOpenHelper(Context context){ super(context, &quot;person.db&quot;, null, 1); } @Override public void onCreate(SQLiteDatabase db) { String sql = &quot;create table person (id integer primary key autoincrement,name varchar(20),phone varchar(20),age integer,address varchar(50));&quot;; db.execSQL(sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } 在com.gunther.contenProvider.provider包中创建，PersonContentProvider类继承ContentProvider类。同时将该Provider在AndroidManifest.xml中注册。 &lt;provider android:exported=&quot;true&quot; android:name=&quot;com.gunther.contenProvider.provider.PersonContentProvider&quot; android:authorities=&quot;com.gunther.person&quot; /&gt; public class PersonContentProvider extends ContentProvider { //用于存放并匹配个Uri标识信息，一般在静态代码块中对其信息进行初始化操作 private static UriMatcher matcher; //声明一个用于操作数据库对象 private PersonOpenHelper openHelper; //主机名信息：对应清单文件的authorities属性 private static final String AUTHORITY = &quot;com.itheima.person&quot;; //数据库 表名 private static final String TABLE_PERSON_NAME = &quot;person&quot;; //Uri匹配成功的返回码 private static final int PERSON_INSERT_CODE = 1000; private static final int PERSON_DELETE_CODE = 10001; private static final int PERSON_UPDATE_CODE = 10002; private static final int PERSON_QUERYALL_CODE = 10003; private static final int PERSON_QUERYONE_CODE = 10004; //静态代码块，用于初始化UriMatcher static{ //NO_MATCH:没有Uri匹配的时候返回的状态码（-1） matcher = new UriMatcher(UriMatcher.NO_MATCH); //添加一个分机号： //对person表进行添加操作，如果Uri=content://com.itheima.person/person/insert,则返回PERSON_INSERT_CODE matcher.addURI(AUTHORITY, &quot;person/insert&quot;, PERSON_INSERT_CODE); //对person表进行删除操作,如果Uri= content://com.itheima.person/person/delete,则返回PERSON_DELETE_CODE matcher.addURI(AUTHORITY, &quot;person/delete&quot;, PERSON_DELETE_CODE); //对person表进行修改操作,如果Uri= content://com.itheima.person/person/update,则返回PERSON_UPDATE_CODE matcher.addURI(AUTHORITY, &quot;person/update&quot;, PERSON_UPDATE_CODE); //对person表进行查询所有操作,如果Uri= content://com.itheima.person/person,则返回PERSON_QUERYALL_CODE matcher.addURI(AUTHORITY, &quot;person&quot;, PERSON_QUERYALL_CODE); //对person表进行查询单个操作,如果Uri= content://com.itheima.person/person/#,(#：代表数字)则返回PERSON_QUERYONE_CODE matcher.addURI(AUTHORITY, &quot;person/#&quot;, PERSON_QUERYONE_CODE); } @Override public boolean onCreate() { //内容提供者中，获取contenxt，是通过getContext，与测试类一样，不能再成员变量，构造函数中调用，但是可以再onCreate方法中获取。 openHelper = new PersonOpenHelper(getContext()); return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { //用匹配器去匹配uri，如果匹配成功则返回匹配器中对应的状态码 int matchCode = matcher.match(uri); SQLiteDatabase db = openHelper.getReadableDatabase(); switch (matchCode) { case PERSON_QUERYALL_CODE: return db.query(TABLE_PERSON_NAME, projection, selection, selectionArgs, null, null, sortOrder); case PERSON_QUERYONE_CODE: //使用ContentUris工具类解析出uri中的id long parseId = ContentUris.parseId(uri); return db.query(TABLE_PERSON_NAME, projection,&quot;id=?&quot;, new String[]{parseId+&quot;&quot;}, null, null, sortOrder); default: throw new IllegalArgumentException(&quot;Uri匹配失败：&quot;+uri); }} @Override public Uri insert(Uri uri, ContentValues values) { SQLiteDatabase db = openHelper.getWritableDatabase(); //新插入对象的id long id = db.insert(TABLE_PERSON_NAME, null, values); db.close(); //使用ContentUris工具类将id追加到uri中，返回给客户 return ContentUris.withAppendedId(uri, id); } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db = openHelper.getWritableDatabase(); //返回删除的个数 int count = db.delete(TABLE_PERSON_NAME, selection, selectionArgs); //关闭数据库 db.close(); return count; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { SQLiteDatabase db = openHelper.getWritableDatabase(); //返回更新的个数 int count = db.update(TABLE_PERSON_NAME, values, selection, selectionArgs); //更新数据库 db.close(); return count; } @Override public String getType(Uri uri) { return null; } } ​ ContentObserverContentObserver——内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。触发器分为表触发器、行触发器，相应地ContentObserver也分为“表“ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。 private class AppLockObserver extends ContentObserver{ public AppLockObserver(){ super(new Handler()); } @Override public void onChange(boolean selfChange) { super.onChange(selfChange); //观察到注册的uri数据发送变化，根据业务需求处理 } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：Service两种绑定方式详解]]></title>
      <url>%2F2016%2F12%2F13%2FServiceLearningForTwoBind%2F</url>
      <content type="text"><![CDATA[简介 使用说明 启动与绑定 简介很多情况下，一些与用户很少需要产生交互的应用程序，我们一般让它们在后台运行就行了，而且在它们运行期间我们仍然能运行其他的应用。为了处理这种后台进程，Android引入了Service的概念。 Service在Android中是一种长生命周期的组件，它不实现任何用户界面,是一个没有界面的组件，由其他组件开启。 Service长期在后台运行, 执行不关乎界面的一些操作比如: 网易新闻服务,每隔1分钟去服务查看是否有最新新闻。 Service和Thread有点相似,但是使用Thread不安全, 不严谨。 Service和其他组件一样，都是运行在主线程中，因此不能用它来做耗时的操作。 使用说明 创建Service，定义类继承Service，AndroidManifest.xml中定义 开启Service，在其他组件中调用startService方法startService(intent);（在activity中可以直接调用），会执行onstartCommand(生命周期方法)(onStart()以过期的方法)，如果发现service还没有，就会先创建执行oncreate。onCreate只会执行一次，服务一旦被创建出来，就不会再执行onCreate方法，以后再去开启服务只会执行onStartCommand。停止Service，调用stopService方法，会执行onDestory()（生命周期方法）。 服务也是运行在主线程中，耗时操作需要放到子线程中，不然会出现anr setForegound(true)(直接在service里调用)，为了避免服务被杀死，我们可以指定这个服务为前台进程。 服务在执行生命周期方法时，也是一个前台进程。广播接收者也一样，在执行生命周期方法onReceive时，也是一个前台进程。 启动与绑定 startService()，标准开启模式。 bindService()，绑定模式。 标准开启模式：被开启的service通过其他组件调用 startService()被创建。这种service可以无限地运行下去，必须调用stopSelf()方法或者其他组件调用stopService()方法来停止它。当service被停止时，系统会销毁它。 绑定模式：被绑定的service是当其他组件（一个客户）调用bindService()来创建的。客户可以通过一个IBinder接口和service进行通信。客户可以通过 unbindService()方法来关闭这种连接。一个service可以同时和多个客户绑定，当多个客户都解除绑定之后，系统会销毁service。 Service的这两种生命周期并不是完全分开的。也就是说，你可以和一个已经调用了 startService()而被开启的service进行绑定。 比如，一个后台音乐service可能因调用 startService()方法而被开启了，稍后，可能用户想要控制播放器或者得到一些当前歌曲的信息，可以通过bindService()将一个activity和service绑定。这种情况下，stopService()或 stopSelf()实际上并不能停止这个service，除非所有的客户都解除绑定。 绑定服务方法：bindService(intent,serviceConnection,int flag);在其他组件中调用此方法，调用后服务内部的生命周期方法onBind方法执行，一旦绑定成功，onBind只执行一次，再次绑定，onBind不会执行。 serviceConnection：连接对象，连接上服务之后可以调用服务的方法传入一个自定义的ServiceConnection用来接收IBinder。实例化ServiceConnection对象，重写内部方法onServiceConnected(ComponentName name,IBinder Binder)：绑定成功获取连接时，执行的方法。 unBindService()解除绑定服务，内部调用服务的生命周期方法onUnbind()，然后调用onDestory()销毁服务。服务只能被解除绑定一次，如果unBindService方法被调用多次，就会出错。 public class TestService extends Service { int mStartMode; IBinder mBinder; boolean mAllowRebind; @Override public void onCreate() { } @Override public int onStartCommand(Intent intent, int flags, int startId) { return mStartMode; } @Override public IBinder onBind(Intent intent) { bindService() return mBinder; } @Override public boolean onUnbind(Intent intent) { return mAllowRebind; } @Override public void onRebind(Intent intent) { bindService(), } @Override public void onDestroy() { destroyed } } Service生命周期]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：BroadcastReceiver实例详解]]></title>
      <url>%2F2016%2F12%2F13%2FBroadcastReceiverDemoLearning%2F</url>
      <content type="text"><![CDATA[简介 生命周期 自定义广播 简介在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的Broadcast进行过滤接受并响应的一类组件。广播接收者（BroadcastReceiver）用于接收广播Intent的, 广播Intent的发送是通过调用sendBroadcast/sendOrderedBroadcast来实现的。通常一个广播Intent可以被订阅了此Intent的多个广播接收者所接收。 生命周期广播接收者也是运行在主线程中，所以在广播接收者的onReceive方法内不能有耗时的操作，需要放在子线程中做，但是onReceive的生命周期很短，有可能广播接收者结束，子线程还没有结束，这时广播接收者所在进程很有可能被杀掉，这样子线程就会出问题，所以耗时操作最好放到service服务中。 广播接收者的生命周期是非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁。 广播接收者中不要做一些耗时的工作，否则会弹出ANR错误对话框。 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉 自定义广播无序广播：所有接收无序广播的广播接收者在此广播被发送时均能接收到此广播，并且是同时接收到。无序广播不可以被拦截，如果被拦截的话会报错： BroadcastReceiver trying to return result during a non-ordered broadcast public void sendBroadcast(View view){ //定义一个意图 Intent intent = new Intent(); //设置Action intent.setAction(&quot;com.itheima.broadcast&quot;); //绑定数据 intent.putExtra(&quot;data&quot;, &quot;我是无序广播数据&quot;); //发送无序广播 sendBroadcast(intent); } 注意： 符号某广播条件的所有广播接收者的特点，无序，无优先级，不可中断，不可传递数据。 广播时可设置接收者权限，仅当接收者含有权限才能接收。 接收者的也可设置发送方权限，只接收含有权限应用的广播Receiver节点增加属性permission。 发送广播时，通过intent.setFlags(intent.flag_include_stopped_pakeages)，包含从未启动过的程序，这样设置，可以让从未启动的接收者也收到广播。 有序广播： 无序广播使用sendOrderedBroadcast方法来发送 接收者可以在中定义android:priority定义优先级，数字越大优先级越高，优先级的取值范围是: 1000(最高) ~ -1000(最低)谷歌规定最大是1000，但是他的类型其实是int。系统默认优先级是0，那么想在系统程序之前接收到广播，那么就设置大于0的数，相同优先级下,接收的顺序要看在清单文件中声明注册的顺序。 有序广播可以被拦截或添加数据，优先级高的接收者可以拦截优先级低的 ，使用abortBroadcast方法拦截， 添加数据：通过bundle传递。前面的接收者可以将数据通过setResultExtras(Bundle)方法存放进结果对象，然后传给下一个接收者，下一个接收者通过代码：Bundle bundle = getResultExtras(true))可以获取上一个接收者存入在结果对象中的数据。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void sendOrder(View view) { Intent intent = new Intent(); intent.setAction(&quot;com.gunther.data&quot;); sendOrderedBroadcast(intent, null, null, null, RESULT_OK, &quot;1万元钱&quot;, null); } public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); String resultData = getResultData(); Toast.makeText(context, &quot;MyReceiver接收到&quot;+action+&quot;发布的广播：&quot;+resultData, 1).show(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：Activity生命周期使用说明]]></title>
      <url>%2F2016%2F12%2F13%2FActivityLifecycle%2F</url>
      <content type="text"><![CDATA[简介 使用流程 跳转方式 生命周期 Activity的简介Activity是Android四大组件之一，它用于展示界面。Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。 使用流程 定义类继承Activity 在AndroidManifest.xml的节点中声明 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; Intent-filter子节点：添加意图过滤，可以通过隐式意图启动。可以在桌面生成快捷方式，应用程序的入口。 跳转方式 显式跳转：在可以引用到那个类, 并且可以引用到那个类的字节码时可以使用，一般用于自己程序的内部，显式跳转不可以跳转到其他程序的页面中。 隐式跳转：可以在当前程序跳转到另一个程序的页面，隐式跳转不需要引用到那个类,但是必须得知道那个界面的action和category。 Activity之间通过Intent进行通信。Intent，用于描述一个页面的信息,同时也是一个数据的载体。 你可以用startActivity(),或startActivityForResult()(如果你想要Activity返回数据)传递一个Intent来开启一个Activity(或者让它做一些其他东西)。 Intent除了可以激活组件，还可以通过封装的Bundle对象来携带数据。所以在启动一个Activity的时候，同时还可以传递数据，然后在新的Activity中可以获得意图对象以获取其中Bundle保存的数据。 Intent可传递的数据类型有: 八大基本数据类型，String,数组,ArrayList, Bundle数据捆, 实现序列化接口的 Javabean 隐式跳转打开浏览器界面：1. 配置文件 2.程序代码 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;http&quot; /&gt; &lt;data android:scheme=&quot;https&quot; /&gt; &lt;data android:scheme=&quot;about&quot; /&gt; &lt;data android:scheme=&quot;javascript&quot; /&gt; &lt;/intent-filter&gt; //跳转到浏览器界面代码 public void skip2Browser(View view){ //创建一个Intent对象 Intent intent = new Intent(); //设置Action intent.setAction(&quot;android.intent.action.VIEW&quot;); //设置category intent.addCategory(&quot;android.intent.category.BROWSABLE&quot;); //设置参数 intent.setData(Uri.parse(&quot;http://www.itheima.com&quot;)); //启动Activity startActivity(intent); } 生命周期Activity有三种状态： 当它在屏幕前台时,响应用户操作的Activity, 它是激活或运行状态。 当它上面有另外一个Activity，使它失去了焦点但仍然对用户可见时, 它处于暂停状态。 当它完全被另一个Activity覆盖时则处于停止状态。 当Activity从一种状态转变到另一种状态时，会调用其生命周期方法。![Activity lifecycle](http://ohiad05ib.bkt.clouddn.com/basic-lifecycle.png) startActivity开启一个Activity时, 生命周期的过程是: onCreate —onStart(可见不可交互) —onResume(可见可交互) 点击back键关闭一个Activity时, 生命周期的过程是: onPause(部分可见不可交互) —onStop(完全不可见) —onDestroy(销毁) 当开启一个新的Activity(以对话框形式)，新的activity把后面的activity给盖住一部分时，后面的activity的生命周期执行的方法是:onPause(部分可见, 不可交互)。注意：指定Activity以对话框的形式显示, 需在activity节点追加以下主题android:theme=”@android:style/Theme.Dialog” 当把新开启的Activity(以对话框形式)给关闭时, 后面的activity的生命周期执行的方法是: onResume(可见，可交互) 当开启一个新的activity把后面的activity完全盖住时, 生命周期的方法执行顺序是: onPause —onStop(完全不可见)。 当把新开启的activity(完全盖住)给关闭时, 生命周期的方法执行顺序是: onRestart—onStart —onResume(可见, 可交互)。 实际应用场景：onResume 可见, 可交互，在该方法中可进行刷新数据操作；onPause 可见，但是不能响应用户操作，在该方法中可进行操作暂停；onCreate 初始化布局以及一些大量的数据；onDestroy 把数据给释放掉, 节省内存。 保存Activity信息 onSaveInstanceState：在Activity被动的摧毁或停止的时候调用，用于保存运行数据，可以将数据存在在Bundle中。onPause之后执行。被动消耗，指被系统回收，不是主动调用finish方法。 onRestoreInstanceState：该方法在Activity被重新绘制的时候调用，例如改变屏幕方向，savedInstanceState为onSaveInstanceState保存的数据。 Activity重新创建，恢复数据，onStart之后执行。如果activity停止之后，进程在后头很容易被杀死，然后重新启动，就会执行恢复数据方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：架构概述]]></title>
      <url>%2F2016%2F12%2F12%2FAndroidInfrastructure%2F</url>
      <content type="text"><![CDATA[系统架构图及各层介绍 Applications应用层：应用是用Java语言编写的运行在虚拟机上的程序，比如Email客户端，SMS短消息程序，日历等。 Application Framework应用框架层：这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架来开发自己的应用，这样便简化了程序开发的结构设计，但是必须要遵守其框架的开发原则。 Libraries系统运行库（C/C++库以及Android运行库）层：当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其更好的为我们服务，比如其中的SQLite（关系数据库），Webkit（Web浏览器引擎）。 Linux Kernel内核层：Android的核心系统服务给予Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核，比如Binder IPC(Internet Process Connection进程间通信)驱动，android的一个特殊驱动程序，具有单独的设备节点，提供进程间通信的功能。 Dalvik VM和JVM的区别 传统JVM编写.java文件—-编译为.class文件—-打包成.jar文件，将java源码编译为class文件，然后将一组class打包成jar。基于栈结构，栈存储于内存中，所以需要用到内存空间 Dalvik VM编写.java文件—-编译为.class文件—-打包成.dex文件—-打包成.apk文件。将一组class编译为一个dex文件，然后有的平台为了更高的效率会将一个dex转换成odex文件。将N多个class文件编译为一个dex，这样执行效率会比较快，更适合在移动平台运行。基于寄存器的结构，寄存器在cpu中，所以用到cpu的空间 DVM与JVM的区别： ART模式概述ART模式是Android Runtime的简称，从Android 4.2开始出现。在Android 4.2以前，安卓手机系统的应用程序均在Dalvik Java的虚拟机上运行，这种运行模式是还要依靠一个编译器来实现与应用程序的沟通。应程序每次运行时，都需要将程序内的代码及时转变为机器码才能运行，这无形中多附加了一道手续，这就造成了耗电相对较快、占用内存大、即使是旗舰机用久了也会卡顿严重的现象。ART模式通过在安装应用程序时，自动对程序进行代码预读取编译，让程序直接编译成机器语言，免去了Dalvik模式要时时转换代码，实现高效率、省电、占用更低的系统内存、手机运行流畅。但凡事总有正反两面，ART在解决了该问题的同时，同时也有如：会占用略高一些的存储空间、安装程序时要相比普通Dalvik模式要长一些时间来实现预编译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：SQLite数据存储]]></title>
      <url>%2F2016%2F12%2F12%2FSQLiteIO%2F</url>
      <content type="text"><![CDATA[SQLite数据库的特点SQLite，是一款轻量型的数据库，是遵守ACID(原子性、一致性、隔离性、持久性)的关联式数据库管理系统，多用于嵌入式开发中。Android平台中嵌入了一个关系型数据库SQLite，和其他数据库不同的是SQLite存储数据时不区分类型，例如一个字段声明为Integer类型，我们也可以将一个字符串存入，一个字段声明为布尔型，我们也可以存入浮点数。除非是主键被定义为Integer，这时只能存储64位整数，SQLite，无需安装，是Android平台自带的一个数据库。 创建数据库的表时可以不指定数据类型，例如： CREATE TABLE person(id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(20)) SQLite支持大部分标准SQL语句，增删改查语句都是通用的，分页查询语句和MySQL相同 SELECT * FROM person LIMIT 20 OFFSET 10 SELECT * FROM person LIMIT 10,20 SQLite与MySql的不同之处主键自增长：SQLite是autoincrement，MySql是auto_increment主键：SQLite主键一般定义为_id，在做查询时要求主键列名必须是_id(本身不是_id，可以起别名)，不然拿不到主键值。 获取可读数据库、可写数据库的区别可读的数据库也有可能可以写，可读的数据库在获取实例时有可能拿到上一次可写的数据库 创建数据库 定义类继承SQLiteOpenHelper 声明构造函数，4个参数 重写onCreate()方法 重写upGrade()方法 public class PersonOpenHelper extends SQLiteOpenHelper { public PersonOpenHelper(Context context, String name, CursorFactory factory, int version) { super(context, name, factory, version); } public void onCreate(SQLiteDatabase db) { // 数据库第一次被创建的时候执行如下sql语句创建一个person表 db.execSQL(&quot;create table person(id integer primary key autoincrement, name varchar(20), phone varchar(20), money integer(20),age integer(10));&quot;); } public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { // 数据库的版本更新的时候执行 if (oldVersion == 1 &amp;&amp; newVersion == 2) { db.execSQL(&quot;alter table person add column balance integer&quot;); } } } 创建一个PersonOpenHelper类来测试上面的代码 public class PersonOpenHelperTest extends AndroidTestCase { public SQLiteDatabase getDataBase(){ PersonOpenHelper helper = new PersonOpenHelper(getContext(), &quot;person.db&quot;, null, 1); SQLiteDatabase writableDatabase = helper.getWritableDatabase(); return writableDatabase; } } 执行完上面代码后，通过DDMS，查看/data/data/com.包名.sqlite/databases目录，发现产生了两个文件，person.db和person.db-journal。其中第一个文件就是我们的数据库文件。 第一次操作数据库时，person.db-journal文件会被自动创建，该文件是sqlite的一个临时的日志文件，主要用于sqlite数据库的事务回滚操作了。 但是Android系统中将该文件永久的保存在磁盘中，不会被自动清除的，如果没有操作异常或者不需要事务回滚时，此文件的大小为0。这种机制避免了每次生成和删除person.db-journal文件的开销。 在测试类中创建该类对象，调用getWritableDatabase()或者getReadableDatabase()：如果数据库不存在，创建数据库文件，执行onCreate()方法，并获取数据库对象。如果数据库存在，版本号没有发生改变，直接获取数据库对象。如果数据库存在，版本号提升，先执行onUpgrade()方法，再获取数据库对象。 数据库并不是初始化MyHelper时创建。如果版本号降低，应用降级。并且不重写onDowngrade，就会调用父类的onDowngrade方法，抛出异常。一般不重写，没这个需求。 SQLiteDataBase自带的增删改查SQLiteDatabase专门提供了对应于添加（insert）、删除（delete）、更新（update）、查询（query）的操作方法。 这些方法封装了部分SQL语句，通过参数进行拼接，这些方法实际上是给那些不太了解SQL语法的开发者使用的。对于熟悉SQL语法的程序员而言，直接使用execSQL()和rawQuery()方法执行SQL语句就能完成数据的添加、删除、更新、查询操作。 这四个方法主要是在使用内容提供者时使用，因为ContentProvider中提供的增删改查方法，与这一套一样，方便调用传参。(等学完ContentProvider自然明白)insert(“表名”,nullColumnHack,””,contentValue) nullColumnHack:如果写null，就无法插入一条空数据（2.3会出异常，4.0之后可以写null） 如果想插入空数据，第二个参数必须写一个列名（任意列） 这个列名是用来拼接sql语句的，如果contentValue为空，则后台不知道表的列名，无法构建sql语句 ContentValue:键值对：键对应列明，值对应插入的值 返回值 long id，插入的主键id delete(“表名”,条件，条件值)，返回受影响的行数。update(“表名”,contentValues(更新列、值),条件，条件值)，返回受影响的行数query(“表名”, 查询的字段, 条件, 条件值);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android：SharedPreference实例详解]]></title>
      <url>%2F2016%2F12%2F12%2FSharedPreferenceDemoLearning%2F</url>
      <content type="text"><![CDATA[在Android系统中，常用的数据储存方式有四种： 存储在手机内存中ROM 存储在SD卡中 存储在SharedPreferences中 存储在SQLite数据库中 在这里只介绍Android特有的SP和SQLite SharedPreferencesSharedPreferences是Android平台上一个轻量级的存储类，主要是保存一些常用的配置，它提供了Android平台常规的Long、Int、String字符串型的保存。 SharedPreferences类似过去Windows系统上的ini配置文件，但是它分为多种权限，可以全局共享访问，整体效率来看不是特别的高，对于常规的轻量级而言比SQLite要好不少，如果真的存储量不大可以考虑自己定义文件格式。 xml 处理时Dalvik会通过自带底层的本地XML Parser解析，比如XMLpull方式，这样对于内存资源占用比较好。 这种方式应该是用起来最简单的Android读写外部数据的方法了。他以一种简单、 透明的方式来保存一些用户个性化设置的字体、颜色、位置等参数信息。一般的应用程序都会提供“设置”或者“首选项”的这样的界面，那么这些设置最后就可以通过Preferences来保存，而程序员不需要知道它到底以什么形式保存的，保存在了什么地方。当然，如果你愿意保存其他的东西，也没有什么限制。只是在性能上不知道会有什么问题。在Android系统中该文件保存在：/data/data/PACKAGE_NAME /shared_prefs 目录下。下面是一个使用SP做数据存储模拟用户登录的案例：布局文件： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;EditText android:layout_marginTop=&quot;10dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot; android:hint=&quot;请输入用户名&quot; android:id=&quot;@+id/et_username&quot; /&gt; &lt;EditText android:layout_marginTop=&quot;10dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; android:id=&quot;@+id/et_pwd&quot; /&gt; &lt;LinearLayout android:layout_marginTop=&quot;10dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;right&quot; &gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登陆&quot; android:onClick=&quot;login&quot; /&gt; &lt;CheckBox android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;保存密码&quot; android:layout_marginRight=&quot;10dp&quot; android:id=&quot;@+id/cb&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 案例代码： public class MainActivity extends Activity { private EditText et_username; private EditText et_pwd; private CheckBox cb; //声明一个SharedPreferences对象 private SharedPreferences sp; /* * 为了方便，因此将用户名和密码设置为常量 */ private static final String PWD = &quot;123456&quot;; private static final String USERNAME = &quot;wzy&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* * 第二个参数代表的是创建该文件的访问范围（权限），通常并建议选择MODE_PRIVATE，该值为0， * 意思是只有当前应用可以访问该文件。而还有2个可选项MODE_WORLD_READABLE 和MODE_WORLD_WRITEABLE * 值分别为1和2已经废除，因为这两种方式可以允许其他应用来访问此文件，这是很不安全的。 */ sp = getSharedPreferences(&quot;info&quot;, MODE_PRIVATE); et_username = (EditText) findViewById(R.id.et_username); et_pwd = (EditText) findViewById(R.id.et_pwd); cb = (CheckBox) findViewById(R.id.cb); /* * 从sp中获取用户信息，用户数据的回显 * 第二个参数为默认返回值，也就是当要查找的key-value不存在时，返回的数据 */ String username = sp.getString(&quot;username&quot;, &quot;&quot;); String pwd = sp.getString(&quot;pwd&quot;, &quot;&quot;); et_username.setText(username); et_pwd.setText(pwd); } public void login(View view){ String userName = et_username.getText().toString(); String pwd = et_pwd.getText().toString(); boolean checked = cb.isChecked(); /* * 用户名和密码如果为空，则提示用户。 */ if (TextUtils.isEmpty(userName)) { Toast.makeText(this, &quot;用户名不能为空！&quot;, Toast.LENGTH_SHORT).show(); return ; } if (TextUtils.isEmpty(pwd)) { Toast.makeText(this, &quot;密码不能为空！&quot;, Toast.LENGTH_SHORT).show(); return ; } /* * 如果用户选择了保存密码,则将用户名和密码保存在手机内存中 * 如果没有选择就将文件删除 */ if (USERNAME.equals(userName)&amp;&amp;PWD.equals(pwd)) { if (checked) { /* * 在对sp进行写、修改需要获取Editor对象 */ Editor editor = sp.edit(); editor.putString(&quot;username&quot;, userName); editor.putString(&quot;pwd&quot;, pwd); /* * 此处非常重要，执行完修改或者写操作后只有调用sp的commit方法，数据才会被保存下来。 */ editor.commit(); }else {//删除用户文件 Editor editor = sp.edit(); /* * 删除该sp中的所有数据 */ editor.clear(); editor.commit(); } Toast.makeText(this, &quot;恭喜您，登陆成功！&quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(this, &quot;对不起，登陆失败！&quot;, Toast.LENGTH_SHORT).show(); } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Axure7.0绘制电影App交互原型图例]]></title>
      <url>%2F2016%2F12%2F10%2Faxuremovie%2F</url>
      <content type="text"><![CDATA[声明：最近还原了一款电影App的原型设计，里面包含一些简易的交互设计，仅供学习交流 AxShare在线HTML文件：点击预览(国内没梯子可能会访问受限)源文件：点击下载 页面树 电影 影院 发现 我的母版电影用户界面 电影内容显示区 待映内容 榜单内容 影院 影院屏幕显示区 详情页内容 发现 发现屏幕显示区 社区显示区 我的 我的屏幕显示区]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个小事例来谈用户特征分析方法论]]></title>
      <url>%2F2016%2F12%2F10%2FUserCharacterAnalysis%2F</url>
      <content type="text"><![CDATA[场景：在某陌生人社交平台上，每次上线之后，都会有很多陌生女性主动发起对话，以一些诱导的方式进行索取微信或者QQ账号，使得平台的聊天环境变得比较恶劣，如果我是该平台产品经理，针对这个案例会如何做用户分析，并且制定相应的解决方案？ 个体分析从后台调取数据进行用户行为分析 抽离用户信息： 用户行为分析： 在短时间内加很多人 在线时间极长 ID用一段时间就作废了 回复非常快 主动发起对话 前20个聊天记录中，包含QQ号码 注册完就马上加一堆好友 关键路径 猜测关键关键的行为有哪些？ 明确特征的算法 命中行为的路径是什么？ 抽象出的关键路径： 注册——&gt;疯狂加人——&gt;诱导式聊天——&gt;跳出平台 验证分析 把关键行为特征交叉后调出数据，然后验证 命中率：有多少命中策略的数据被调取出来了 准确率：调出的数据中，准确率是多少 优化数据，调整粒度 解决方案 用户特征分析越详实，解决方案越准确 假设上述算法筛选的数据是准确无误的，则可以指定相关方案给这种用户警告或者封号，能够减少这种损害平台的行为 用户特征分析的逻辑顺序 个体分析——&gt;关键路径——&gt;验证分析——&gt;解决方案 行为分析是重中之重]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用产品画布分析一款互联网产品]]></title>
      <url>%2F2016%2F12%2F05%2FProductMap%2F</url>
      <content type="text"><![CDATA[首先明确两个概念 产业地图 产品画布 什么是产业地图？产业地图是一种分析产业链的工具，通过将产业链中的角色标准化，引导思维，完成梳理过程。它包括四个角色：供应商、渠道商、营销媒介、用户。下面是一幅健身领域的产业地图： 产品画布分析一款典型产品的商业模式，有两种主导逻辑。 营销逻辑关心产品的业务关系。用户的痛点是什么？解决方案是什么？关键核心指标是什么？ 财务逻辑关心成本和收益。产品的发展情况？盈利能力如何？运营是不是有效率？ 那么产品画布的框架可以有效地将两者结合起来： 一.用户痛点用户迫切的需求。 二.解决方案罗列产品的特性，筛选后留下核心的竞争力的功能。 三.关键指标围绕核心业务，得到关键指标。比如滴滴打车，共享经济方式，解决乘客端便捷打车、司机端提升座位利用率的需求。这是个基于效率最大化的业务模式，所以提升运营效率是关键。滴滴打车的核心关键指标是乘客上车时间，是乘客从发起打车需求到开始乘车的时间间隔。围绕滴滴打车的核心业务，关键指标不是打车的人越多越好，不是在线的车越多越好，是乘客的乘车需求与附近车辆的座位空置率的匹配度。 明确围绕核心业务的关键指标，可以方便了对应产品的业务发展状态。 四.独特卖点目标用户为什么选择这款产品，而不是其他？针对用户的痛点，同时对比其他产品，这款产品，能够提供什么特别的价值？ 解决方案的优势是什么？可以拆分两个层面去思考： 基本属性 尖叫属性 我们可以思考一下自己常用的产品，我们为什么选择了它？电商我喜欢用京东。自营可信赖、品类丰富、评价真实，属于基本属性。物流闪电速度、配送员专业，属于尖叫属性。 五.核心资源借助核心资源是帮助产品突出重围。关键资源一般包括： 资本，拥有雄厚的资金实力，方便开展市场活动，例如，外卖红包大战。 专利，拥有IP，例如，网红Papi酱的视频。 人力，拥有某行业人力，例如，医生专家资源。 背景，拥有强大的合作伙伴，例如，开发小程序，腾讯系公司可以拿到微信社交API，而其他公司不可以。 六.渠道渠道可以划分为线下渠道和线上渠道。 线下渠道聘请地推团队推广、做平面广告、线下用户活动等。互联网虽然强大，但很多冷启动时的互联网产品，也会选择建设地推团队在做线下推广。地推常见的方式是，扫码送礼物、发传单优惠券等。 线上渠道KOL合作、Campaign、Native Ads（原生广告：在网站、APP中正常内容一样的广告）、Coop Branding等。 七.用户细分用户细分，是营销中的STP理论，包含三个部分：市场细分（Segmentation）、目标市场选择（Targeting）和定位（Position）。这对于早期产品尤为重要，针对细分市场，提供细分用户的定向服务，精细化培育种子用户，为产品发展打下基础，例如知乎早期的注册邀请机制。用户细分有两个大的维度，基本属性和行为属性。 基本属性：年龄、性别、职业、地区等。 行为属性：兴趣爱好、使用场合、忠诚度等。 八.成本结构互联网行业，成本包括： 固定成本：人力、服务器、办公场地等。 可变成本：根绝产品阶段不同对应的运营推广费用等。 九.收入来源互联网产品的商业变现模式，具体问题具体分析，此处只简单罗列 。对于一款APP来说，可以包含： 一次性付费下载（MindNode） 付费试用内部高级功能（印象笔记） 内部广告（游戏广告） 付费会员（视频产品）…… 下面是虾米音乐App的简单产品画布分析：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何进行零秒思考？]]></title>
      <url>%2F2016%2F12%2F03%2FLogicThinking%2F</url>
      <content type="text"><![CDATA[零秒思考阅读，写作是培养逻辑思维能力的正道，但是要想短时间有一定的收获，需要一些相当有技巧的办法，最近看了一本叫《零秒思考》的书，介绍了一种锻炼思维的方法，每天花费10分钟到20分钟，坚持一段时间， 思维能力会提升不少，能够很有效的帮助你快住抓住问题的核心，清晰的表达 一个想法的产生到终结的过程：1.情感涌现2.想法浮现3.整理思考4.某种程度浮现的语言5.做笔记6.着手解决问题 怎样进行零秒思考？工具：A4纸，中性笔写作方式：每一页左上角标题，标题下方正文，日期时间控制：每天10页，每页1分到2分 这种思考方式的本质是什么？本质是逻辑树的深入挖掘，大多数人在出现想法的时候，总是犹豫不决，原地转圈，而照这样的情况发展下去，同样的问题还是会在相同的情境之下跳出来困扰你，将思考的这些事情，记录下来，这些事情就大致得到了解决，烦恼，问题也会锐减，对自我的认知也会更加深刻，不要想10个是不是有一点少，每天想10个完全不一样的问题也不是一件你容易的事情 为什么不建议使用软件或者笔记本？从行为路径上来说，使用软件的操作流程和笔记本的流程是这样的，打开手机或者电脑–打开软件–建立空白文档–打字–保存，属于同步行为，拿出纸和笔–记录，属于异步路径，行为路径太长会是让自己的想法流失，从思路整理的角度来说，笔记本有着刻意的顺序，而想法是无序的，对于思路的整理有一定的约束性，使用A4纸是为了 后期进行一些主题整理，而且使用成本低，像意识流写作一样，随想随写 笔记如何整理？建议使用一个文件夹来存放A4纸单页，一个月一整 有什么注意的？标题可以是问句，陈述句，切记是在整理思路，不要刻意的去强调格式，如果在这基础上发展出了自己的一种整理方式，那再好不过了，坚持100天，你会发现大不同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 语法]]></title>
      <url>%2F2016%2F12%2F01%2FMDGrammer%2F</url>
      <content type="text"><![CDATA[Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 举一个栗子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F14%2FHelloWorld%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
